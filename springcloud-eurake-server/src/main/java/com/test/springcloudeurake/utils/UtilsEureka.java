package com.test.springcloudeurake.utils;

/*
 * 网站架构演变过程：
 * 		传统架构（单点应用）-->分布式架构（以项目进行拆分）-->SOA架构（面向服务架构）-->微服务架构
 *  一.传统项目就是以SSH或者SSM框架开发 	典型的三层架构 dao、service、controller，单个项目
 *  	适用于单人或小团队开发  缺点：耦合度太高，一个模块出问题可能导致其他模块出问题
 *
 *  二.分布式架构 从传统项目演变而成。  将项目模块拆分多个项目  降低耦合度  多个war包 多个jvm通讯
 *
 *  三.SOA架构 从分布式架构演变而成。   面向服务（服务：将共同的业务逻辑进行拆分，没有视图层）、
 *  	将共同的业务代码进行抽取出来，提供给其他接口调用。服务与服务之间是通过RPC远程调用技术。
 *      服务概念可以理解为接口
 *		rpc远程调用技术框架：httpclient、springcloud、dubbo、grpc（核心底层socket技术或者netty实现）
 *				两个或者多个应用实现远程调用
 *		SOA架构特点：底层基于SOAP或者ESB（消息总线）实现，使用http或者https+重量级xml数据交换格式进行通讯
 *		WebService底层是http+xml（SOAP协议 简单数据交换）
 *		以后微服务以json格式替代xml
 *	SOA架构缺点：
 *		1.依赖中心化服务发现机制
 *		2.采用SOAP协议（http+xml），xml传输协议比较占用宽带，整个xml报文中有非常大的冗杂数据
 *		3.服务管理非常混乱，缺少服务管理和治理设施不完善
 *  SOA架构图：
 *                                            浏览器访问
 *                                                ↓
 *                                                ↓
 *                                        PC    ： pc_web
 *     Web控制层（没有任何页面）            微信端： weixin_web           移动端web或者小程序
 *                                        H5   ： h5_web                /
 *                                                ↓                   /     直接调用服务层
 *                           （通过rpc远程通讯调用）↓                 /
 *                                                ↓               /
 *                                          （会员服务） （商品服务）
 *     SOA架构层（服务层）                    （支付服务） （交易服务）
 *                                          （微信服务） （优惠券服务）
 *
 *	四.微服务架构模式 从SOA架构演变而成 更精细 目的是为了提高效率。每个服务与服务之间互不影响，每个服务必须独立部署。
 *		更加体现轻量级，采用restful风格提供api，也就是http+json
 *
 *     微服务与SOA的区别：
 *      1.微服务架构由SOA演变，继承SOA优点，去除ESB消息总线，使用http+json(restful)进行传输
 *      2.SOA数据库数据可以共享，微服务每个服务都是单独数据库，保证服务之间互不影响
 *      3.微服务目的是提高效率，比SOA更精细，能快速迭代版本，更适合互联网公司敏捷开发
 *
 *	五.SpringCloud：是基于SpringBoot开发的微服务框架，目前来说是一套比较完整的微服务解决框架，其内容包括服务治理、
 *		配置管理、智能路由、微代理、控制总线、全局锁、分布式会话等。
 *	    SpringCloud包含众多的子项目
 *			SpringCloud config 分布式配置中心
 *			SpringCloud netflix 核心组件
 *					Eureka：服务治理 注册中心
 *					Hystrix：服务保护框架
 *					Ribbon：客户端负载均衡
 *					Feign：基于Ribbon和Hystrix的声明式服务调用组件
 *					Zuul：网关组件，提供智能路由、访问过滤等功能
 *
 *		1.服务注册与发现，在任何rpc远程框架中，都会有一个注册中心
 *		    注册中心：存放服务地址相关消息（接口地址）
 *                  SpringCloud支持三种注册中心：Eureka(Eureka2.0闭源)、Consul（go语言编写）、Zookeeper
 *                  Dubbo支持两种：Redis和Zookeeper
 *          rpc远程调用框架核心思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）
 *          步骤：i.启动注册中心（eureka）会缓存到jvm中，默认情况下每隔30秒更新一次服务调用地址
 *               ii.启动服务  iii.服务启动时会把当前服务基本信息（地址和端口等）以别名形式注册到注册中心
 *               iv.消费者在调用接口的时候，使用服务别名也就是serviceid去注册中心上获取实际rpc远程调用地址
 *               v.如果消费者获取到实际rpc远程调用地址之后，再使用本地httpclient技术实现
 *
 *
 *      2.服务治理
 *          传统rpc远程调用框架中管理每个服务与服务之间的依赖关系比较复杂。
 *          传统rpc服务之间直接调用，使用httpclient.get("http://192.168.1.1/test")，当服务url很多的情况下管理非常复杂。
 *          在数据库有一张表（存放调用服务地址） urlkey：调用服务名称 urladress：调用地址
 *
 *        微服务重要核心就是服务治理，当注册中心因故障无法使用会导致整个服务不可用
 *        因此需要集群EurekaServer，使他们互相可用，并且需要3台以上，也就是高可用
 *
 *  六.Eureka server服务端 , client客户端 客户端注册服务到服务端
 *      自我保护机制：为了防止误剔除，默认情况下client会定时发送心跳包给server。如果server在一定时间没有收到client的心跳包，便会
 *          剔除该服务，默认90s，如果短时间丢失了大量的服务实例心跳，这时候会触发自我保护机制，不剔除服务。
 *      如果服务真的宕机，本地调用应该使用重试机制、保证接口网络延迟幂等性、服务降级功能。
 */

public class UtilsEureka {
}
